turn 1
To solve the problem of calculating the n-th Fibonacci number, we need to first understand the Fibonacci sequence itself. The Fibonacci sequence is defined as follows:

- The first two numbers in the sequence are 0 and 1.
- Every subsequent number is the sum of the two preceding ones.

The sequence starts like this:
- F(0) = 0
- F(1) = 1
- F(2) = F(0) + F(1) = 0 + 1 = 1
- F(3) = F(1) + F(2) = 1 + 1 = 2
- F(4) = F(2) + F(3) = 1 + 2 = 3
- F(5) = F(3) + F(4) = 2 + 3 = 5
- F(6) = F(4) + F(5) = 3 + 5 = 8
- F(7) = F(5) + F(6) = 5 + 8 = 13
- F(8) = F(6) + F(7) = 8 + 13 = 21
- F(9) = F(7) + F(8) = 13 + 21 = 34
- F(10) = F(8) + F(9) = 21 + 34 = 55

From the problem statement, we need to return the n-th Fibonacci number, where the input `n` is 1-based (i.e., fib(1) should return 1, fib(2) should return 1, etc.). However, the Fibonacci sequence typically starts from F(0) = 0. To align with the provided examples, we will adjust our indexing accordingly.

### Approach

1. **Base Cases**: We need to handle the base cases for n = 1 and n = 2, which both return 1.
2. **Iterative Calculation**: For n > 2, we can use an iterative approach to compute the Fibonacci numbers up to n. This is efficient in terms of both time and space complexity.
3. **Space Optimization**: Instead of storing all Fibonacci numbers in a list, we can keep track of only the last two Fibonacci numbers, as they are sufficient to compute the next number in the sequence.

### Implementation Steps

1. Define the function `fib(n: int)`.
2. Check for the base cases (n = 1 and n = 2).
3. Use a loop to calculate Fibonacci numbers iteratively for n > 2.
4. Return the n-th Fibonacci number.

Now, let's implement the function based on this reasoning.

```python
def fib(n: int) -> int:
    """Return n-th Fibonacci number.
    >>> fib(10)
    55
    >>> fib(1)
    1
    >>> fib(8)
    21
    """
    if n == 1 or n == 2:
        return 1
    
    # Initialize the first two Fibonacci numbers
    a, b = 1, 1
    
    # Calculate Fibonacci numbers iteratively
    for _ in range(3, n + 1):
        a, b = b, a + b  # Update to the next Fibonacci numbers
    
    return b  # b now holds the n-th Fibonacci number

# Testing the function with provided examples
print(fib(10))  # Output: 55
print(fib(1))   # Output: 1
print(fib(8))   # Output: 21
```

### Explanation of the Code

- The function starts by checking if `n` is 1 or 2, returning 1 in both cases.
- For values of `n` greater than 2, we initialize two variables `a` and `b` to represent the last two Fibonacci numbers (both starting at 1).
- We then iterate from 3 to `n`, updating `a` and `b` to the next Fibonacci numbers in each iteration.
- Finally, we return `b`, which contains the n-th Fibonacci number after the loop completes.

This implementation is efficient with a time complexity of O(n) and a space complexity of O(1), making it suitable for calculating Fibonacci numbers even for larger values of `n`.
PASS: All tests passed