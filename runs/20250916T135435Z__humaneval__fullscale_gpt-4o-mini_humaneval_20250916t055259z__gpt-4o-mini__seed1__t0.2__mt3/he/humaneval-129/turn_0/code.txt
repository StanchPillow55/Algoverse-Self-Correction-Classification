def minPath(grid, k):
    from collections import deque
    
    N = len(grid)
    min_path = None
    
    def dfs(x, y, path):
        nonlocal min_path
        if len(path) == k:
            if min_path is None or path < min_path:
                min_path = path[:]
            return
        
        # Explore neighbors
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < N and 0 <= ny < N:  # Check bounds
                path.append(grid[nx][ny])
                dfs(nx, ny, path)
                path.pop()  # Backtrack
    
    # Start DFS from every cell in the grid
    for i in range(N):
        for j in range(N):
            dfs(i, j, [grid[i][j]])
    
    return min_path

# Example usage:
grid1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
k1 = 3
print(minPath(grid1, k1))  # Output: [1, 2, 1]

grid2 = [[5, 9, 3], [4, 1, 6], [7, 8, 2]]
k2 = 1
print(minPath(grid2, k2))  # Output: [1]